{% extends 'base.html' %}
{% set monitor_settings = app_settings.monitor or {} %}
{% set monitor_defaults = monitor_defaults or {} %}
{% set show_map = monitor_settings.show_map if monitor_settings.show_map is not none else True %}
{% set show_incidents = monitor_settings.show_incidents if monitor_settings.show_incidents is not none else True %}
{% set clock_with_seconds = monitor_settings.clock_with_seconds if monitor_settings.clock_with_seconds is not none else False %}
{% block head_extra %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html, body { overflow: hidden; }
  .vehicle-label {
    background: rgba(0, 0, 0, 0.8);
    color: #f8f9fa;
    border-radius: 4px;
    padding: 2px 4px;
    font-size: 0.8rem;
    font-weight: 600;
    border: 1px solid rgba(255, 255, 255, 0.2);
    text-transform: uppercase;
  }
</style>
{% endblock %}
{% block container_class %}container-fluid p-0 vh-100 d-flex flex-column{% endblock %}
{% block content %}
<div class="monitor-page">
  <header class="monitor-header">
    <div class="monitor-title">
      <h1 class="mb-1">Alarmmonitor</h1>
      <p class="mb-0 text-white-50">Live Übersicht für Einsätze &amp; Fahrzeuge</p>
    </div>
    <div class="monitor-meta">
      <div class="monitor-time text-end" id="datetime" aria-live="polite"></div>
      <div class="monitor-actions">
        <div id="audio-status" class="monitor-audio-status" role="status" aria-live="polite"></div>
        <button id="fullscreen" class="btn btn-outline-light btn-sm">Vollbild</button>
      </div>
    </div>
  </header>
  <main class="monitor-content">
    {% if show_map %}
    <section class="monitor-map" aria-label="Karte">
      <div id="map" class="monitor-map-canvas"></div>
    </section>
    {% endif %}
    <section class="monitor-table" aria-label="Fahrzeugstatus">
      <div id="latest-incident" class="monitor-alert alert alert-danger" role="status" style="display:none;"></div>
      <div id="vehicle-table-container" class="monitor-table-body">
        <table class="table table-dark table-striped" id="vehicle-table">
          <thead>
            <tr>
              <th>Fahrzeug / Funkrufname</th>
              <th>Status</th>
              <th>Ort</th>
            </tr>
          </thead>
          <tbody>
          {% for name, info in vehicles.items() %}
            <tr data-unit="{{ name }}" class="status-{{ info.status }}">
              <td class="unit-cell"><strong>{{ info.name }}</strong><br><small>{{ info.callsign }}</small></td>
              <td class="status-text">{{ info.status }} - {{ status_text[info.status] }}</td>
              <td class="location">{{ info.location }}</td>
            </tr>
          {% endfor %}
          </tbody>
        </table>
      </div>
    </section>
    {% if show_incidents %}
    <section class="monitor-incidents" aria-label="Aktive Einsätze">
      <div class="monitor-incidents-header">
        <div>
          <h2 class="mb-1">Aktive Einsätze</h2>
          <p class="mb-0 text-white-50" id="active-incident-summary">Keine aktiven Einsätze</p>
        </div>
      </div>
      <div class="monitor-incidents-body" id="active-incident-list" role="list"></div>
    </section>
    {% endif %}
  </main>
</div>
<audio id="alarm" preload="auto">
  <source src="{{ url_for('static', filename='gong.mp3') }}" type="audio/mpeg">
  <source src="{{ url_for('static', filename='gong.wav') }}" type="audio/wav">
</audio>
{% endblock %}
{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const vehicleData = {{ vehicles|tojson }};
const statusText = {{ status_text|tojson }};
const monitorDefaults = {{ monitor_defaults|tojson }} || {};
const monitorSettings = Object.assign({}, monitorDefaults, {{ monitor_settings|tojson }} || {});
const operationAreaInitial = {{ app_settings.operation_area|tojson }} || {};
const fallbackLat = 50.517;
const fallbackLon = 8.816;
const fallbackZoom = 13;
function toNumber(value, fallback) {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : fallback;
}
let mapDefaultLat = toNumber(operationAreaInitial.lat, fallbackLat);
let mapDefaultLon = toNumber(operationAreaInitial.lon, fallbackLon);
let mapDefaultZoom = Math.max(3, Math.min(18, toNumber(operationAreaInitial.zoom, fallbackZoom)));
let operationArea = {
    name: (operationAreaInitial.name || '').trim(),
    lat: mapDefaultLat,
    lon: mapDefaultLon,
    zoom: mapDefaultZoom,
};
const lastAlarmIds = {};
let lastAlarmUnit = null;
const vehicleIcons = {};
const seenAnnouncements = new Set();
const seenAnnouncementOrder = [];
const SEEN_ANNOUNCEMENT_LIMIT = 200;
let announcementsInitialised = false;
for (const [unit, info] of Object.entries(vehicleData)) {
    const initId = info.alarm_time || info.incident_id;
    lastAlarmIds[unit] = initId ? `${unit}:${initId}` : null;
    if (info.icon) {
        vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
    }
}
const alarmSound = document.getElementById('alarm');
const latestDiv = document.getElementById('latest-incident');
const audioStatusEl = document.getElementById('audio-status');
const fullscreenBtn = document.getElementById('fullscreen');
const docEl = document.documentElement;
const requestFullscreen =
  docEl.requestFullscreen?.bind(docEl) ||
  docEl.webkitRequestFullscreen?.bind(docEl) ||
  docEl.mozRequestFullScreen?.bind(docEl) ||
  docEl.msRequestFullscreen?.bind(docEl);
const exitFullscreen =
  document.exitFullscreen?.bind(document) ||
  document.webkitExitFullscreen?.bind(document) ||
  document.mozCancelFullScreen?.bind(document) ||
  document.msExitFullscreen?.bind(document);

function getFullscreenElement() {
  return (
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.mozFullScreenElement ||
    document.msFullscreenElement ||
    null
  );
}
const datetimeEl = document.getElementById('datetime');
const AUDIO_PREFS = {
  'gong-and-tts': { gong: true, tts: true },
  'gong-only': { gong: true, tts: false },
  'tts-only': { gong: false, tts: true },
  'mute': { gong: false, tts: false },
};
const audioMode = String(monitorSettings.audio_mode || 'gong-and-tts').toLowerCase();
const audioPrefs = AUDIO_PREFS[audioMode] || AUDIO_PREFS['gong-and-tts'];
const requiresAudioUnlock = Boolean(audioPrefs.gong || audioPrefs.tts);
const configuredVolume = Number(monitorSettings.gong_volume);
const gongVolume = Number.isFinite(configuredVolume)
  ? Math.min(1, Math.max(0, configuredVolume))
  : 1;
if (alarmSound) {
  alarmSound.volume = gongVolume;
}
const showClockSeconds = {{ 'true' if clock_with_seconds else 'false' }};
let audioUnlocked = !requiresAudioUnlock;
let monitorSettingsCurrent = Object.assign({}, monitorSettings);
const ttsEl = new Audio();
ttsEl.volume = gongVolume;
let lastAlarmId = null;
const alarmQueue = [];
let alarmProcessing = false;
let refreshing = false;
let refreshQueued = false;
const mapContainer = document.getElementById('map');
const map = mapContainer ? L.map('map').setView([mapDefaultLat, mapDefaultLon], mapDefaultZoom) : null;
if (map) {
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '© OpenStreetMap'}).addTo(map);
}
const vehicleMarkers = {};
const incidentMarkers = {};
const incidentListEl = document.getElementById('active-incident-list');
const incidentSummaryEl = document.getElementById('active-incident-summary');
const INCIDENT_AUTO_SCROLL_SPEED = 14; // pixels per second
let incidentAutoScrollHandle = null;
let incidentAutoScrollDirection = 1;
let incidentAutoScrollLastTimestamp = null;
let incidentAutoScrollRefreshHandle = null;
let incidentAutoScrollResidual = 0;
const tableContainer = document.getElementById('vehicle-table-container');
const vehicleTableEl = document.getElementById('vehicle-table');
let vehicleTableBaseFontSize = null;
let pendingTableResize = false;
function setOperationArea(area) {
    if (!area) return false;
    const lat = toNumber(area.lat, mapDefaultLat);
    const lon = toNumber(area.lon, mapDefaultLon);
    const zoomValue = Math.max(3, Math.min(18, toNumber(area.zoom, mapDefaultZoom)));
    const name = (area.name || '').trim();
    const changed =
        lat !== mapDefaultLat ||
        lon !== mapDefaultLon ||
        zoomValue !== mapDefaultZoom ||
        name !== (operationArea.name || '');
    operationArea = {
        name,
        lat,
        lon,
        zoom: zoomValue,
    };
    mapDefaultLat = lat;
    mapDefaultLon = lon;
    mapDefaultZoom = zoomValue;
    if (map && !Object.keys(incidentMarkers).length) {
        map.setView([mapDefaultLat, mapDefaultLon], mapDefaultZoom);
    }
    return changed;
}

setOperationArea(operationAreaInitial);

function formatDateTime(value, options = {}) {
    if (!value) return '—';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return value;
    const base = {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    };
    return date.toLocaleString('de-DE', { ...base, ...options });
}

function formatTime(value) {
    if (!value) return '';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return '';
    return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
}

function ensureVehicleTableBaseFontSize() {
    if (!vehicleTableEl) return null;
    if (!vehicleTableBaseFontSize) {
        vehicleTableEl.style.fontSize = '';
        vehicleTableBaseFontSize = parseFloat(window.getComputedStyle(vehicleTableEl).fontSize);
        if (!vehicleTableBaseFontSize) {
            vehicleTableBaseFontSize = 16;
        }
    }
    return vehicleTableBaseFontSize;
}

function adjustVehicleTableSize() {
    if (!tableContainer || !vehicleTableEl) return;
    const tbody = vehicleTableEl.tBodies[0];
    if (!tbody || !tbody.rows.length) return;
    const baseFontSize = ensureVehicleTableBaseFontSize();
    if (!baseFontSize) return;
    if (pendingTableResize) return;
    pendingTableResize = true;
    tableContainer.classList.remove('table-scaled');
    vehicleTableEl.style.fontSize = `${baseFontSize}px`;
    requestAnimationFrame(() => {
        const thead = vehicleTableEl.tHead;
        const computed = window.getComputedStyle(tableContainer);
        const paddingTop = parseFloat(computed.paddingTop) || 0;
        const paddingBottom = parseFloat(computed.paddingBottom) || 0;
        const availableHeight = Math.max(tableContainer.clientHeight - paddingTop - paddingBottom, 0);
        const headerHeight = thead ? thead.getBoundingClientRect().height : 0;
        const rows = Array.from(tbody.rows);
        const totalRowHeight = rows.reduce((sum, row) => sum + row.getBoundingClientRect().height, 0);
        const maxContentHeight = Math.max(availableHeight - headerHeight, 0);
        if (!totalRowHeight || maxContentHeight <= 0) {
            vehicleTableEl.style.fontSize = `${baseFontSize}px`;
            tableContainer.classList.remove('table-scaled');
            pendingTableResize = false;
            return;
        }
        let scale = maxContentHeight / totalRowHeight;
        if (!Number.isFinite(scale) || scale <= 0) scale = 1;
        const minScale = 0.35;
        scale = Math.min(1, Math.max(minScale, scale));
        vehicleTableEl.style.fontSize = `${baseFontSize * scale}px`;
        requestAnimationFrame(() => {
            const tableHeight = vehicleTableEl.getBoundingClientRect().height;
            const containerHeight = tableContainer.clientHeight;
            const usableHeight = Math.max(containerHeight - paddingTop - paddingBottom, 0);
            if (tableHeight > usableHeight + 1 && scale > minScale) {
                const adjustedScale = Math.max(minScale, scale * (usableHeight / tableHeight));
                vehicleTableEl.style.fontSize = `${baseFontSize * adjustedScale}px`;
                scale = adjustedScale;
            }
            tableContainer.classList.toggle('table-scaled', scale < 0.999);
            pendingTableResize = false;
        });
    });
}
const iconBase = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/';

function resizeMap() {
    if (!map) return;
    requestAnimationFrame(() => map.invalidateSize());
}
if (map) {
    window.addEventListener('resize', resizeMap);
    window.addEventListener('load', resizeMap);
}
document.addEventListener('DOMContentLoaded', () => {
    resizeMap();
    updateAlertPadding();
    setTimeout(resizeMap, 200);
    adjustVehicleTableSize();
    setTimeout(adjustVehicleTableSize, 250);
    scheduleIncidentAutoScrollRefresh();
});

if (tableContainer) {
    window.addEventListener('resize', adjustVehicleTableSize);
    if ('ResizeObserver' in window) {
        const tableResizeObserver = new ResizeObserver(() => adjustVehicleTableSize());
        tableResizeObserver.observe(tableContainer);
    }
}

if (incidentListEl && 'ResizeObserver' in window) {
    const incidentResizeObserver = new ResizeObserver(() => scheduleIncidentAutoScrollRefresh());
    incidentResizeObserver.observe(incidentListEl);
}

window.addEventListener('resize', () => scheduleIncidentAutoScrollRefresh());

if (vehicleTableEl && vehicleTableEl.tBodies && vehicleTableEl.tBodies[0] && 'MutationObserver' in window) {
    const tableMutationObserver = new MutationObserver(() => adjustVehicleTableSize());
    tableMutationObserver.observe(vehicleTableEl.tBodies[0], {childList: true, subtree: true, characterData: true});
}
function computeAlarmId(unit, info) {
    const uniqueId = info.alarm_time || info.incident_id || Date.now();
    return `${unit}:${uniqueId}`;
}

function renderActiveIncidents(incidents) {
    if (!incidentListEl) return;
    const container = incidentListEl;
    container.innerHTML = '';
    const active = Array.isArray(incidents)
        ? incidents.filter(inc => inc && inc.active)
        : [];
    if (!active.length) {
        const empty = document.createElement('div');
        empty.className = 'monitor-incident-empty';
        empty.textContent = 'Keine aktiven Einsätze';
        container.appendChild(empty);
        if (incidentSummaryEl) {
            incidentSummaryEl.textContent = 'Keine aktiven Einsätze';
        }
        stopIncidentAutoScroll();
        container.scrollTop = 0;
        return;
    }
    const sorted = active
        .slice()
        .sort((a, b) => {
            const aStart = a?.start || '';
            const bStart = b?.start || '';
            return bStart.localeCompare(aStart);
        });
    sorted.forEach(inc => {
        const card = document.createElement('article');
        card.className = 'monitor-incident-card';
        card.setAttribute('role', 'listitem');

        const header = document.createElement('header');
        header.className = 'monitor-incident-card__header';

        const headerInfo = document.createElement('div');
        const idSpan = document.createElement('span');
        idSpan.className = 'monitor-incident-id';
        idSpan.textContent = `#${inc.id}`;
        headerInfo.appendChild(idSpan);

        const title = document.createElement('h3');
        title.textContent = inc.keyword || 'Einsatz';
        headerInfo.appendChild(title);

        const location = document.createElement('p');
        location.className = 'monitor-incident-location';
        const loc = inc.location || {};
        location.textContent = loc.name || '—';
        headerInfo.appendChild(location);

        const meta = document.createElement('div');
        meta.className = 'monitor-incident-meta';

        const priority = document.createElement('span');
        priority.className = 'monitor-incident-priority';
        priority.textContent = inc.priority || '—';
        meta.appendChild(priority);

        const start = document.createElement('span');
        start.className = 'monitor-incident-start';
        start.textContent = formatDateTime(inc.start);
        meta.appendChild(start);

        header.appendChild(headerInfo);
        header.appendChild(meta);
        card.appendChild(header);

        const unitList = document.createElement('ul');
        unitList.className = 'monitor-incident-unit-list';
        const assigned = Array.isArray(inc.vehicles) ? inc.vehicles : [];
        if (assigned.length) {
            assigned.forEach(unit => {
                const li = document.createElement('li');
                li.className = 'monitor-incident-unit';
                const info = vehicleData[unit];
                const statusCode = info && info.status !== undefined ? Number(info.status) : null;
                const statusKey = statusCode !== null && !Number.isNaN(statusCode) ? String(statusCode) : null;
                if (statusKey) {
                    li.classList.add(`status-${statusKey}`);
                } else {
                    li.classList.add('status-unknown');
                }
                const nameSpan = document.createElement('span');
                nameSpan.className = 'unit-name';
                nameSpan.textContent = unit;
                const statusSpan = document.createElement('span');
                statusSpan.className = 'unit-status';
                if (statusKey && statusText[statusKey]) {
                    statusSpan.textContent = `Status ${statusKey} – ${statusText[statusKey]}`;
                } else if (statusCode !== null && !Number.isNaN(statusCode)) {
                    statusSpan.textContent = `Status ${statusCode}`;
                } else {
                    statusSpan.textContent = 'Status unbekannt';
                }
                li.appendChild(nameSpan);
                li.appendChild(statusSpan);
                unitList.appendChild(li);
            });
        } else {
            const li = document.createElement('li');
            li.className = 'monitor-incident-unit status-unknown';
            li.textContent = 'Keine Fahrzeuge zugeordnet';
            unitList.appendChild(li);
        }
        card.appendChild(unitList);

        const lastNote = inc.notes && inc.notes.length ? inc.notes[inc.notes.length - 1] : null;
        if (lastNote && lastNote.text) {
            const note = document.createElement('p');
            note.className = 'monitor-incident-note';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'note-time';
            timeSpan.textContent = formatTime(lastNote.time);
            const textSpan = document.createElement('span');
            textSpan.className = 'note-text';
            textSpan.textContent = lastNote.text;
            note.appendChild(timeSpan);
            note.appendChild(textSpan);
            card.appendChild(note);
        }

        container.appendChild(card);
    });
    if (incidentSummaryEl) {
        incidentSummaryEl.textContent = active.length === 1
            ? '1 aktiver Einsatz'
            : `${active.length} aktive Einsätze`;
    }
    scheduleIncidentAutoScrollRefresh();
}

function stopIncidentAutoScroll() {
    if (incidentAutoScrollHandle !== null) {
        cancelAnimationFrame(incidentAutoScrollHandle);
        incidentAutoScrollHandle = null;
    }
    if (incidentAutoScrollRefreshHandle !== null) {
        cancelAnimationFrame(incidentAutoScrollRefreshHandle);
        incidentAutoScrollRefreshHandle = null;
    }
    incidentAutoScrollLastTimestamp = null;
    incidentAutoScrollResidual = 0;
}

function runIncidentAutoScroll(timestamp) {
    if (!incidentListEl) {
        stopIncidentAutoScroll();
        return;
    }
    const maxScroll = incidentListEl.scrollHeight - incidentListEl.clientHeight;
    if (maxScroll <= 0) {
        incidentListEl.scrollTop = 0;
        stopIncidentAutoScroll();
        return;
    }
    if (incidentAutoScrollLastTimestamp === null) {
        incidentAutoScrollLastTimestamp = timestamp;
    }
    const deltaSeconds = (timestamp - incidentAutoScrollLastTimestamp) / 1000;
    incidentAutoScrollLastTimestamp = timestamp;
    const offset = deltaSeconds * INCIDENT_AUTO_SCROLL_SPEED * incidentAutoScrollDirection;
    incidentAutoScrollResidual += offset;
    let wholeOffset = 0;
    if (incidentAutoScrollResidual >= 1) {
        wholeOffset = Math.floor(incidentAutoScrollResidual);
    } else if (incidentAutoScrollResidual <= -1) {
        wholeOffset = Math.ceil(incidentAutoScrollResidual);
    }
    if (wholeOffset !== 0) {
        incidentAutoScrollResidual -= wholeOffset;
        let nextTop = incidentListEl.scrollTop + wholeOffset;
        if (nextTop <= 0) {
            nextTop = 0;
            incidentAutoScrollDirection = 1;
            incidentAutoScrollLastTimestamp = timestamp;
            incidentAutoScrollResidual = 0;
        } else if (nextTop >= maxScroll) {
            nextTop = maxScroll;
            incidentAutoScrollDirection = -1;
            incidentAutoScrollLastTimestamp = timestamp;
            incidentAutoScrollResidual = 0;
        }
        incidentListEl.scrollTop = nextTop;
    }
    incidentAutoScrollHandle = requestAnimationFrame(runIncidentAutoScroll);
}

function startIncidentAutoScroll() {
    stopIncidentAutoScroll();
    if (!incidentListEl) return;
    if (incidentListEl.scrollHeight <= incidentListEl.clientHeight + 1) {
        incidentListEl.scrollTop = 0;
        return;
    }
    incidentAutoScrollDirection = 1;
    incidentAutoScrollLastTimestamp = null;
    incidentAutoScrollResidual = 0;
    incidentAutoScrollHandle = requestAnimationFrame(runIncidentAutoScroll);
}

function scheduleIncidentAutoScrollRefresh() {
    if (incidentAutoScrollRefreshHandle !== null) return;
    incidentAutoScrollRefreshHandle = requestAnimationFrame(() => {
        incidentAutoScrollRefreshHandle = null;
        startIncidentAutoScroll();
    });
}

let audioContext = null;

function ensureAudioContext() {
    if (!requiresAudioUnlock) return null;
    if (audioContext) return audioContext;
    const Ctor = window.AudioContext || window.webkitAudioContext;
    if (!Ctor) return null;
    try {
        audioContext = new Ctor();
    } catch (err) {
        audioContext = null;
    }
    return audioContext;
}

function warmupAudioContext() {
    const ctx = ensureAudioContext();
    if (!ctx) return Promise.resolve(false);
    if (typeof ctx.resume === 'function' && ctx.state === 'suspended') {
        return ctx.resume().then(() => true).catch(() => false);
    }
    return Promise.resolve(true);
}

function playFallbackChime() {
    const ctx = ensureAudioContext();
    if (!ctx) return Promise.resolve(false);
    return new Promise(resolve => {
        try {
            const oscillator = ctx.createOscillator();
            const gain = ctx.createGain();
            gain.gain.value = 0.0001;
            oscillator.type = 'triangle';
            oscillator.frequency.value = 880;
            oscillator.connect(gain).connect(ctx.destination);
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.12);
            oscillator.onended = () => resolve(true);
            oscillator.onerror = () => resolve(false);
        } catch (err) {
            resolve(false);
        }
    });
}

function updateAudioStatus() {
    if (!audioStatusEl) return;
    if (!requiresAudioUnlock) {
        const active = Boolean(audioPrefs.gong || audioPrefs.tts);
        audioStatusEl.dataset.state = active ? 'ready' : 'muted';
        audioStatusEl.textContent = active ? 'Audio aktiv' : 'Audio deaktiviert';
        audioStatusEl.setAttribute('aria-label', active ? 'Audio aktiv' : 'Audio deaktiviert');
        audioStatusEl.classList.toggle('is-clickable', false);
        return;
    }
    const state = audioUnlocked ? 'ready' : 'locked';
    audioStatusEl.dataset.state = state;
    audioStatusEl.textContent = audioUnlocked ? 'Audio bereit' : 'Tippen für Audio';
    audioStatusEl.setAttribute(
        'aria-label',
        audioUnlocked ? 'Audio aktiviert' : 'Audio gesperrt – tippen zum Aktivieren'
    );
    audioStatusEl.classList.toggle('is-clickable', !audioUnlocked);
}

updateAudioStatus();

function hexToRgbString(value) {
    if (typeof value !== 'string') return null;
    const trimmed = value.trim();
    const match = /^#?([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(trimmed);
    if (!match) return null;
    let hex = match[1];
    if (hex.length === 3) {
        hex = hex.split('').map(ch => ch + ch).join('');
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    if ([r, g, b].some(component => Number.isNaN(component))) return null;
    return `${r}, ${g}, ${b}`;
}

function applyAccentColor(accent, rgb) {
    if (!accent) return;
    const target = document.body || document.documentElement;
    if (!target || !target.style) return;
    target.style.setProperty('--accent-color', accent);
    const rgbValue = rgb || hexToRgbString(accent);
    if (rgbValue) {
        target.style.setProperty('--accent-color-rgb', rgbValue);
    }
}

function monitorSettingDiffers(key, nextValue) {
    const current = monitorSettingsCurrent[key];
    if (key === 'gong_volume') {
        const currentVolume = Number(current ?? monitorDefaults.gong_volume ?? 1);
        const incoming = Number(nextValue ?? currentVolume);
        return Math.abs(currentVolume - incoming) > 0.001;
    }
    if (key === 'accent_color') {
        const currentColour = (current || '').toLowerCase();
        const incomingColour = (nextValue || '').toLowerCase();
        return currentColour !== incomingColour;
    }
    return current !== nextValue;
}

function handleMonitorSettingsUpdate(newSettings) {
    if (!newSettings || typeof newSettings !== 'object') return;
    const reloadKeys = ['show_map', 'show_incidents', 'audio_mode', 'gong_volume', 'clock_with_seconds', 'show_weather'];
    const requiresReload = reloadKeys.some(key => key in newSettings && monitorSettingDiffers(key, newSettings[key]));
    if (requiresReload) {
        window.location.reload();
        return;
    }
    if ('accent_color' in newSettings && monitorSettingDiffers('accent_color', newSettings.accent_color)) {
        applyAccentColor(newSettings.accent_color, newSettings.accent_color_rgb);
    }
    monitorSettingsCurrent = Object.assign({}, monitorSettingsCurrent, newSettings);
}

function unlockAudio() {
    if (!requiresAudioUnlock || audioUnlocked) {
        updateAudioStatus();
        return;
    }
    const attempts = [];
    if (audioPrefs.gong && alarmSound) {
        alarmSound.currentTime = 0;
        attempts.push(
            alarmSound.play()
                .then(() => {
                    alarmSound.pause();
                    alarmSound.currentTime = 0;
                    return true;
                })
                .catch(() => false)
        );
    }
    attempts.push(warmupAudioContext().catch(() => false));
    attempts.push(playFallbackChime().catch(() => false));
    Promise.all(attempts).then(results => {
        const success = results.some(Boolean);
        audioUnlocked = success;
        updateAudioStatus();
    }).catch(() => {
        audioUnlocked = false;
        updateAudioStatus();
    });
}

if (requiresAudioUnlock) {
    const gestureUnlock = () => unlockAudio();
    document.addEventListener('pointerdown', gestureUnlock, {once: true});
    document.addEventListener('keydown', gestureUnlock, {once: true});
}
if (audioStatusEl) {
    audioStatusEl.addEventListener('click', unlockAudio);
}
function fitMapToAll() {
    if (!map) return;
    const markers = [
        ...Object.values(vehicleMarkers),
        ...Object.values(incidentMarkers)
    ].filter(m => m);
    if (markers.length) {
        const group = new L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.05));
    } else {
        map.setView([mapDefaultLat, mapDefaultLon], mapDefaultZoom);
    }
}
const icons = {
  RTW: new L.Icon({iconUrl: iconBase + 'marker-icon-red.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  KTW: new L.Icon({iconUrl: iconBase + 'marker-icon-blue.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  default: new L.Icon({iconUrl: iconBase + 'marker-icon-grey.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
};
const incidentIcon = new L.Icon({iconUrl: iconBase + 'marker-icon-green.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]});
function getIcon(unit) {
  if (vehicleIcons[unit]) return vehicleIcons[unit];
  if (unit.startsWith('RTW')) return icons.RTW;
  if (unit.startsWith('KTW')) return icons.KTW;
  return icons.default;
}
fullscreenBtn.addEventListener('click', () => {
  if (!requestFullscreen) return;
  if (getFullscreenElement()) {
    exitFullscreen?.();
  } else {
    requestFullscreen().catch(() => {});
  }
});

function updateFullscreenUi() {
  const nav = document.querySelector('nav');
  const isFullscreen = Boolean(getFullscreenElement());
  if (nav) {
    nav.style.display = isFullscreen ? 'none' : '';
  }
  if (fullscreenBtn) {
    if (isFullscreen) {
      fullscreenBtn.style.display = 'none';
    } else {
      fullscreenBtn.style.display = '';
      fullscreenBtn.textContent = 'Vollbild';
    }
  }
}

document.addEventListener('fullscreenchange', updateFullscreenUi);
document.addEventListener('webkitfullscreenchange', updateFullscreenUi);
document.addEventListener('mozfullscreenchange', updateFullscreenUi);
document.addEventListener('MSFullscreenChange', updateFullscreenUi);

function updateDateTime() {
  if (!datetimeEl) return;
  const now = new Date();
  const datePart = now.toLocaleDateString('de-DE', {
    weekday: 'long',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  });
  const timeOptions = {
    hour: '2-digit',
    minute: '2-digit',
    second: showClockSeconds ? '2-digit' : undefined,
    hour12: false,
  };
  const timePart = now.toLocaleTimeString('de-DE', timeOptions).replace('.', ':');
  datetimeEl.innerHTML = `<span class="monitor-date">${datePart}</span><span class="monitor-clock">${timePart}</span>`;
}
setInterval(updateDateTime, 1000);
updateDateTime();
function speak(text) {
    const t = (text || '').trim();
    if (!t || !audioPrefs.tts) return Promise.resolve();
    if (!audioUnlocked) {
        updateAudioStatus();
        return Promise.resolve();
    }
    if ('speechSynthesis' in window && window.speechSynthesis) {
        return new Promise(resolve => {
            const utterance = new SpeechSynthesisUtterance(t);
            utterance.lang = 'de-DE';
            utterance.onend = resolve;
            utterance.onerror = resolve;
            window.speechSynthesis.speak(utterance);
        });
    }
    return new Promise(resolve => {
        const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=de&q=${encodeURIComponent(t)}`;
        ttsEl.src = url;
        ttsEl.onended = resolve;
        ttsEl.play().catch(() => resolve());
    });
}

function rememberAnnouncementId(id) {
    if (!id) return;
    if (seenAnnouncements.has(id)) return;
    seenAnnouncements.add(id);
    seenAnnouncementOrder.push(id);
    while (seenAnnouncementOrder.length > SEEN_ANNOUNCEMENT_LIMIT) {
        const removed = seenAnnouncementOrder.shift();
        if (removed) {
            seenAnnouncements.delete(removed);
        }
    }
}

function enqueueAlarm(item, options = {}) {
    const { playGong = true } = options;
    alarmQueue.push(item);
    if (alarmProcessing) return;
    alarmProcessing = true;
    const shouldPlayGong = Boolean(playGong && audioPrefs.gong && alarmSound);
    if (!shouldPlayGong) {
        processAlarmQueue();
        return;
    }
    if (audioUnlocked) {
        alarmSound.currentTime = 0;
        alarmSound.play()
            .then(() => {
                alarmSound.onended = () => {
                    alarmSound.onended = null;
                    processAlarmQueue();
                };
            })
            .catch(() => {
                playFallbackChime().finally(() => processAlarmQueue());
            });
    } else {
        updateAudioStatus();
        unlockAudio();
        processAlarmQueue();
    }
}

function queueAnnouncement(entry) {
    if (!entry) return;
    const key = entry.id !== undefined && entry.id !== null
        ? String(entry.id)
        : (entry.time ? `time:${entry.time}` : null);
    if (key && seenAnnouncements.has(key)) return;
    const text = (entry.text || '').trim();
    if (!text) {
        if (key) rememberAnnouncementId(key);
        return;
    }
    if (key) rememberAnnouncementId(key);
    const speechText = `Achtung, eine Durchsage: ${text}`;
    enqueueAlarm({
        displayCallsign: 'Durchsage',
        displayPriorityHtml: '',
        displayText: text,
        speechText,
        announcementId: key,
    });
}

function processAnnouncements(list) {
    if (!Array.isArray(list)) return;
    const sorted = list
        .slice()
        .sort((a, b) => {
            const aTime = (a && a.time) || '';
            const bTime = (b && b.time) || '';
            return aTime.localeCompare(bTime);
        });
    if (!announcementsInitialised) {
        sorted.forEach(entry => {
            if (!entry) return;
            const key = entry.id !== undefined && entry.id !== null
                ? String(entry.id)
                : (entry.time ? `time:${entry.time}` : null);
            if (key) {
                rememberAnnouncementId(key);
            }
        });
        announcementsInitialised = true;
        return;
    }
    sorted.forEach(entry => queueAnnouncement(entry));
}

function triggerAlarm(unit, info, alarmId) {
    alarmId = alarmId || computeAlarmId(unit, info);
    if (alarmId === lastAlarmId) return;
    lastAlarmId = alarmId;
    lastAlarmUnit = unit;
    const displayCallsign = info.callsign || unit;
    const speechCallsign = info.tts || displayCallsign;
    const priority = info.priority || '';
    const parts = [`Alarm für ${speechCallsign}`];
    if (priority) parts.push(`Priorität ${priority}`);
    if (info.note) parts.push(info.note);
    if (info.location) parts.push(info.location);
    const speechText = parts.join('. ');
    const displayParts = [];
    if (info.note) displayParts.push(info.note);
    if (info.location) displayParts.push(info.location);
    const displayText = displayParts.join(' ').trim();
    const displayPriorityHtml = priority
        ? `<span class="badge bg-warning text-dark ms-2 me-3">${priority}</span>`
        : '';
    enqueueAlarm({alarmId, displayCallsign, speechText, displayText, displayPriorityHtml});
    if (info.lat && info.lon) {
        if (vehicleMarkers[unit]) {
            vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
            vehicleMarkers[unit].setIcon(getIcon(unit));
            vehicleMarkers[unit].setTooltipContent(displayCallsign);
        } else {
            const marker = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map);
            marker.bindPopup(displayCallsign);
            marker.bindTooltip(displayCallsign, { permanent: true, direction: 'top', offset: [0, -12], className: 'vehicle-label' });
            vehicleMarkers[unit] = marker;
        }
    }
    fitMapToAll();
}

function processAlarmQueue() {
    const item = alarmQueue.shift();
    if (!item) {
        alarmProcessing = false;
        lastAlarmId = null;
        return;
    }
    const fragments = [`<strong>${item.displayCallsign}</strong>`];
    if (item.displayPriorityHtml) fragments.push(item.displayPriorityHtml);
    if (item.displayText) fragments.push(item.displayText);
    latestDiv.innerHTML = fragments.join(' ').trim();
    setLatestIncidentVisible(true);
    speak(item.speechText).then(() => processAlarmQueue());
}

function setLatestIncidentVisible(visible) {
    if (!latestDiv) return;
    const container = latestDiv.closest('.monitor-table');
    if (visible) {
        latestDiv.style.display = 'block';
        latestDiv.classList.add('visible');
        updateAlertPadding();
        if (container) container.classList.add('has-alert');
        requestAnimationFrame(() => {
            updateAlertPadding();
            adjustVehicleTableSize();
        });
    } else {
        latestDiv.style.display = 'none';
        latestDiv.classList.remove('visible');
        if (container) container.classList.remove('has-alert');
        updateAlertPadding();
        requestAnimationFrame(adjustVehicleTableSize);
    }
}

function updateAlertPadding() {
    if (!tableContainer) return;
    const basePadding = 16; // 1rem
    let topPadding = basePadding;
    if (latestDiv && latestDiv.classList.contains('visible')) {
        const alertHeight = latestDiv.getBoundingClientRect().height || 0;
        const offsetTop = latestDiv.offsetTop || 0;
        const gap = 16;
        topPadding = Math.max(basePadding, offsetTop + alertHeight + gap);
    }
    tableContainer.style.setProperty('--monitor-table-top-padding', `${topPadding}px`);
}

async function refresh() {
    if (refreshing) {
        refreshQueued = true;
        return;
    }
    refreshing = true;
    try {
        const [statusRes, incidentsRes, announcementsRes, settingsRes] = await Promise.all([
            fetch('/api/status', {cache: 'no-store'}),
            fetch('/api/incidents', {cache: 'no-store'}),
            fetch('/api/announcements', {cache: 'no-store'}),
            fetch('/api/settings', {cache: 'no-store'})
        ]);
        if (!statusRes.ok || !incidentsRes.ok || !announcementsRes.ok || !settingsRes.ok) {
            throw new Error('Netzwerkfehler');
        }
        const data = await statusRes.json();
        const incs = await incidentsRes.json();
        const announcementsData = await announcementsRes.json();
        const settingsData = await settingsRes.json();
        if (settingsData && settingsData.operation_area) {
            const changed = setOperationArea(settingsData.operation_area);
            if (changed) {
                fetchWeather(true);
            }
        }
        if (settingsData && settingsData.monitor) {
            handleMonitorSettingsUpdate(settingsData.monitor);
        }
        setConnectionStatus(true);
        const tbody = vehicleTableEl ? vehicleTableEl.tBodies[0] : null;
        const existingRows = new Map();
        if (tbody) {
            for (const row of Array.from(tbody.rows)) {
                if (row.dataset && row.dataset.unit) {
                    existingRows.set(row.dataset.unit, row);
                }
            }
        }
        const fetchedUnits = new Set(Object.keys(data));

        for (const [unit, info] of Object.entries(data)) {
            vehicleData[unit] = info;
            let row = existingRows.get(unit);
            if (!row && tbody) {
                row = document.createElement('tr');
                row.dataset.unit = unit;
                row.innerHTML = `
                    <td class="unit-cell"></td>
                    <td class="status-text"></td>
                    <td class="location"></td>
                `;
                tbody.appendChild(row);
            }
            if (!row) continue;
            row.className = `status-${info.status}`;
            const statusLabel = statusText[info.status] || '';
            row.querySelector('.status-text').textContent = `${info.status} - ${statusLabel}`.trim();
            row.querySelector('.location').textContent = info.location || '';
            row.querySelector('.unit-cell').innerHTML = `<strong>${info.name}</strong><br><small>${info.callsign}</small>`;
            if (info.icon) {
                vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
            } else {
                delete vehicleIcons[unit];
            }
            const hasAlertInfo = info.note || info.location;
            const alarmId = (info.alarm_time || info.incident_id) ? computeAlarmId(unit, info) : null;
            if (alarmId && alarmId !== lastAlarmIds[unit]) {
                triggerAlarm(unit, info, alarmId);
            }
            if (lastAlarmUnit === unit && !hasAlertInfo) {
                setLatestIncidentVisible(false);
                lastAlarmUnit = null;
                lastAlarmId = null;
            }
            lastAlarmIds[unit] = alarmId;
            if (map && info.lat && info.lon) {
                if (vehicleMarkers[unit]) {
                    vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
                    vehicleMarkers[unit].setIcon(getIcon(unit));
                    vehicleMarkers[unit].setTooltipContent(info.callsign || unit);
                } else {
                    const marker = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map);
                    const displayCallsign = info.callsign || unit;
                    marker.bindPopup(displayCallsign);
                    marker.bindTooltip(displayCallsign, { permanent: true, direction: 'top', offset: [0, -12], className: 'vehicle-label' });
                    vehicleMarkers[unit] = marker;
                }
            } else if (map && vehicleMarkers[unit]) {
                map.removeLayer(vehicleMarkers[unit]);
                delete vehicleMarkers[unit];
            }
        }

        if (tbody) {
            for (const [unit, row] of existingRows.entries()) {
                if (!fetchedUnits.has(unit)) {
                    row.remove();
                }
            }
        }

        for (const unit of Object.keys(vehicleData)) {
            if (!fetchedUnits.has(unit)) {
                delete vehicleData[unit];
                delete lastAlarmIds[unit];
                delete vehicleIcons[unit];
                if (map && vehicleMarkers[unit]) {
                    map.removeLayer(vehicleMarkers[unit]);
                    delete vehicleMarkers[unit];
                }
                if (lastAlarmUnit === unit) {
                    setLatestIncidentVisible(false);
                    lastAlarmUnit = null;
                    lastAlarmId = null;
                }
            }
        }
        if (map) {
            for (const inc of incs) {
                const loc = inc.location || {};
                if (inc.active && loc.lat && loc.lon) {
                    if (incidentMarkers[inc.id]) {
                        incidentMarkers[inc.id].setLatLng([loc.lat, loc.lon]);
                    } else {
                        incidentMarkers[inc.id] = L.marker([loc.lat, loc.lon], {icon: incidentIcon})
                            .addTo(map)
                            .bindPopup(`${inc.keyword} - ${loc.name}`);
                    }
                } else if (incidentMarkers[inc.id]) {
                    map.removeLayer(incidentMarkers[inc.id]);
                    delete incidentMarkers[inc.id];
                }
            }
        }
        renderActiveIncidents(incs);
        processAnnouncements(announcementsData);
    adjustVehicleTableSize();
    fitMapToAll();
    } catch (err) {
        console.error('Aktualisierung fehlgeschlagen', err);
        setConnectionStatus(false);
    } finally {
        refreshing = false;
        if (refreshQueued) {
            refreshQueued = false;
            refresh();
        }
    }
}
function setConnectionStatus(connected) {
    if (typeof window.__setBackendConnected === 'function') {
        window.__setBackendConnected(Boolean(connected));
    }
}

let eventSource = null;
let reconnectTimer = null;

function scheduleReconnect() {
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectEventStream();
    }, 5000);
}

function connectEventStream() {
    if (eventSource) {
        eventSource.close();
    }
    eventSource = new EventSource('/events');
    eventSource.onopen = () => {
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onmessage = () => {
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onerror = () => {
        setConnectionStatus(false);
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        scheduleReconnect();
    };
}

window.addEventListener('beforeunload', () => {
    if (eventSource) {
        eventSource.close();
    }
});

setConnectionStatus(false);
connectEventStream();
refresh();
setInterval(() => {
    refresh();
}, 30000);
</script>
{% endblock %}
