{% extends 'base.html' %}
{% block head_extra %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html, body { overflow: hidden; }
  .vehicle-label {
    background: rgba(0, 0, 0, 0.8);
    color: #f8f9fa;
    border-radius: 4px;
    padding: 2px 4px;
    font-size: 0.8rem;
    font-weight: 600;
    border: 1px solid rgba(255, 255, 255, 0.2);
    text-transform: uppercase;
  }
</style>
{% endblock %}
{% block container_class %}container-fluid p-0 vh-100 d-flex flex-column{% endblock %}
{% block content %}
<div class="monitor-page">
  <header class="monitor-header">
    <div class="monitor-title">
      <h1 class="mb-1">Alarmmonitor</h1>
      <p class="mb-0 text-white-50">Live Übersicht für Einsätze &amp; Fahrzeuge</p>
    </div>
    <div class="monitor-meta">
      <div class="monitor-time text-end" id="datetime"></div>
      <div class="monitor-controls">
        <button id="enable-audio" class="btn btn-outline-light btn-sm">Ton aktivieren</button>
        <button id="fullscreen" class="btn btn-outline-light btn-sm">Vollbild</button>
      </div>
    </div>
  </header>
  <main class="monitor-content">
    <section class="monitor-map" aria-label="Karte">
      <div id="map" class="monitor-map-canvas"></div>
    </section>
    <section class="monitor-table" aria-label="Fahrzeugstatus">
      <div id="latest-incident" class="monitor-alert alert alert-danger" role="status" style="display:none;"></div>
      <div id="vehicle-table-container" class="monitor-table-body">
        <table class="table table-dark table-striped" id="vehicle-table">
          <thead>
            <tr>
              <th>Fahrzeug / Funkrufname</th>
              <th>Icon</th>
              <th>Status</th>
              <th>Hinweis</th>
              <th>Ort</th>
              <th>Farbe</th>
            </tr>
          </thead>
          <tbody>
          {% for name, info in vehicles.items() %}
            <tr data-unit="{{ name }}" class="status-{{ info.status }}">
              <td class="unit-cell"><strong>{{ info.name }}</strong><br><small>{{ info.callsign }}</small></td>
              <td class="icon-cell">{% if info.icon %}<img src="{{ url_for('static', filename=info.icon) }}" height="28" width="28" class="rounded-circle bg-dark p-1">{% endif %}</td>
              <td class="status-text">{{ info.status }} - {{ status_text[info.status] }}</td>
              <td class="note">{{ info.note }}</td>
              <td class="location">{{ info.location }}</td>
              <td class="status-color-cell"><span class="status-color"></span></td>
            </tr>
          {% endfor %}
          </tbody>
        </table>
      </div>
    </section>
  </main>
</div>
<audio id="alarm" preload="auto">
  <source src="{{ url_for('static', filename='gong.mp3') }}" type="audio/mpeg">
  <source src="{{ url_for('static', filename='gong.wav') }}" type="audio/wav">
</audio>
{% endblock %}
{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const vehicleData = {{ vehicles|tojson }};
const statusText = {{ status_text|tojson }};
const lastAlarmIds = {};
let lastAlarmUnit = null;
const vehicleIcons = {};
for (const [unit, info] of Object.entries(vehicleData)) {
    const initId = info.alarm_time || info.incident_id;
    lastAlarmIds[unit] = initId ? `${unit}:${initId}` : null;
    if (info.icon) {
        vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
    }
}
const alarmSound = document.getElementById('alarm');
const latestDiv = document.getElementById('latest-incident');
const enableBtn = document.getElementById('enable-audio');
const fullscreenBtn = document.getElementById('fullscreen');
const datetimeEl = document.getElementById('datetime');
let audioUnlocked = false;
const ttsEl = new Audio();
let lastAlarmId = null;
const alarmQueue = [];
let alarmProcessing = false;
let refreshing = false;
let refreshQueued = false;
const map = L.map('map').setView([50.517, 8.816], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '© OpenStreetMap'}).addTo(map);
const vehicleMarkers = {};
const incidentMarkers = {};
const iconBase = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/';

function resizeMap() {
    requestAnimationFrame(() => map.invalidateSize());
}
window.addEventListener('resize', resizeMap);
window.addEventListener('load', resizeMap);
document.addEventListener('DOMContentLoaded', () => {
    resizeMap();
    setTimeout(resizeMap, 200);
});
function computeAlarmId(unit, info) {
    const uniqueId = info.alarm_time || info.incident_id || Date.now();
    return `${unit}:${uniqueId}`;
}
function unlockAudio() {
    alarmSound.play().then(() => {
        alarmSound.pause();
        alarmSound.currentTime = 0;
        audioUnlocked = true;
        enableBtn.style.display = 'none';
    }).catch(() => {
        audioUnlocked = false;
        enableBtn.style.display = '';
    });
}
enableBtn.addEventListener('click', unlockAudio, {once: true});
document.addEventListener('touchstart', unlockAudio, {once: true});
document.addEventListener('click', unlockAudio, {once: true});
function fitMapToAll() {
    const markers = [
        ...Object.values(vehicleMarkers),
        ...Object.values(incidentMarkers)
    ].filter(m => m);
    if (Object.keys(incidentMarkers).length === 0) {
        map.setView([50.517, 8.816], 13);
    } else if (markers.length) {
        const group = new L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.05));
    }
}
const icons = {
  RTW: new L.Icon({iconUrl: iconBase + 'marker-icon-red.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  KTW: new L.Icon({iconUrl: iconBase + 'marker-icon-blue.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  default: new L.Icon({iconUrl: iconBase + 'marker-icon-grey.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
};
const incidentIcon = new L.Icon({iconUrl: iconBase + 'marker-icon-green.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]});
function getIcon(unit) {
  if (vehicleIcons[unit]) return vehicleIcons[unit];
  if (unit.startsWith('RTW')) return icons.RTW;
  if (unit.startsWith('KTW')) return icons.KTW;
  return icons.default;
}
fullscreenBtn.addEventListener('click', () => {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  }
});
if (document.documentElement.requestFullscreen) {
  document.documentElement.requestFullscreen().catch(() => {});
}
document.addEventListener('fullscreenchange', () => {
  const nav = document.querySelector('nav');
  if (document.fullscreenElement) {
    if (nav) nav.style.display = 'none';
    fullscreenBtn.style.display = 'none';
  } else {
    if (nav) nav.style.display = '';
    fullscreenBtn.style.display = '';
  }
});

function updateDateTime() {
  const now = new Date();
  datetimeEl.textContent = now.toLocaleString('de-DE');
}
setInterval(updateDateTime, 1000);
updateDateTime();
function speak(text) {
    const t = (text || '').trim();
    if (!t) return Promise.resolve();
      if ('speechSynthesis' in window) {
          return new Promise(resolve => {
              const utterance = new SpeechSynthesisUtterance(t);
              utterance.lang = 'de-DE';
              utterance.onend = resolve;
              utterance.onerror = resolve;
              window.speechSynthesis.speak(utterance);
          });
      }
    if (!audioUnlocked) {
        enableBtn.style.display = '';
        return Promise.resolve();
    }
    return new Promise(resolve => {
        const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=de&q=${encodeURIComponent(t)}`;
        ttsEl.src = url;
        ttsEl.onended = resolve;
        ttsEl.play().catch(() => resolve());
    });
}

function triggerAlarm(unit, info, alarmId) {
    alarmId = alarmId || computeAlarmId(unit, info);
    if (alarmId === lastAlarmId) return;
    lastAlarmId = alarmId;
    lastAlarmUnit = unit;
    const displayCallsign = info.callsign || unit;
    const speechCallsign = info.tts || displayCallsign;
    const priority = info.priority || '';
    const parts = [`Alarm für ${speechCallsign}`];
    if (priority) parts.push(`Priorität ${priority}`);
    if (info.note) parts.push(info.note);
    if (info.location) parts.push(info.location);
    const speechText = parts.join('. ');
    const displayParts = [];
    if (info.note) displayParts.push(info.note);
    if (info.location) displayParts.push(info.location);
    const displayText = displayParts.join(' ').trim();
    const displayPriorityHtml = priority
        ? `<span class="badge bg-warning text-dark ms-2 me-3">${priority}</span>`
        : '';
    alarmQueue.push({alarmId, displayCallsign, speechText, displayText, displayPriorityHtml});
    if (!alarmProcessing) {
        alarmProcessing = true;
        if (audioUnlocked) {
            alarmSound.currentTime = 0;
            alarmSound.play().then(() => {
                alarmSound.onended = () => {
                    alarmSound.onended = null;
                    processAlarmQueue();
                };
            }).catch(() => {
                processAlarmQueue();
            });
        } else {
            enableBtn.style.display = '';
            processAlarmQueue();
        }
    }
    if (info.lat && info.lon) {
        if (vehicleMarkers[unit]) {
            vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
            vehicleMarkers[unit].setIcon(getIcon(unit));
            vehicleMarkers[unit].setTooltipContent(displayCallsign);
        } else {
            const marker = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map);
            marker.bindPopup(displayCallsign);
            marker.bindTooltip(displayCallsign, { permanent: true, direction: 'top', offset: [0, -12], className: 'vehicle-label' });
            vehicleMarkers[unit] = marker;
        }
    }
    fitMapToAll();
}

function processAlarmQueue() {
    const item = alarmQueue.shift();
    if (!item) {
        alarmProcessing = false;
        lastAlarmId = null;
        return;
    }
    const fragments = [`<strong>${item.displayCallsign}</strong>`];
    if (item.displayPriorityHtml) fragments.push(item.displayPriorityHtml);
    if (item.displayText) fragments.push(item.displayText);
    latestDiv.innerHTML = fragments.join(' ').trim();
    latestDiv.style.display = 'block';
    speak(item.speechText).then(() => processAlarmQueue());
}

async function refresh() {
    if (refreshing) {
        refreshQueued = true;
        return;
    }
    refreshing = true;
    try {
        const [statusRes, incidentsRes] = await Promise.all([
            fetch('/api/status', {cache: 'no-store'}),
            fetch('/api/incidents', {cache: 'no-store'})
        ]);
        if (!statusRes.ok || !incidentsRes.ok) {
            throw new Error('Netzwerkfehler');
        }
        const data = await statusRes.json();
        const incs = await incidentsRes.json();
        setConnectionStatus(true);
        for (const [unit, info] of Object.entries(data)) {
        vehicleData[unit] = info;
        const row = document.querySelector(`tr[data-unit="${unit}"]`);
        if (row) {
            row.className = `status-${info.status}`;
            row.querySelector('.status-text').textContent = `${info.status} - ${statusText[info.status]}`;
            row.querySelector('.note').textContent = info.note;
            row.querySelector('.location').textContent = info.location;
            row.querySelector('.unit-cell').innerHTML = `<strong>${info.name}</strong><br><small>${info.callsign}</small>`;
            const iconCell = row.querySelector('.icon-cell');
            if (info.icon) {
                iconCell.innerHTML = `<img src="/static/${info.icon}" height="24">`;
                vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
            } else {
                iconCell.innerHTML = '';
                delete vehicleIcons[unit];
            }
            const hasAlertInfo = info.note || info.location;
            const alarmId = (info.alarm_time || info.incident_id) ? computeAlarmId(unit, info) : null;
            if (alarmId && alarmId !== lastAlarmIds[unit]) {
                triggerAlarm(unit, info, alarmId);
            }
            if (lastAlarmUnit === unit && !hasAlertInfo) {
                latestDiv.style.display = 'none';
                lastAlarmUnit = null;
                lastAlarmId = null;
            }
            lastAlarmIds[unit] = alarmId;
            if (info.lat && info.lon) {
                if (vehicleMarkers[unit]) {
                    vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
                    vehicleMarkers[unit].setIcon(getIcon(unit));
                    vehicleMarkers[unit].setTooltipContent(info.callsign || unit);
                } else {
                    const marker = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map);
                    const displayCallsign = info.callsign || unit;
                    marker.bindPopup(displayCallsign);
                    marker.bindTooltip(displayCallsign, { permanent: true, direction: 'top', offset: [0, -12], className: 'vehicle-label' });
                    vehicleMarkers[unit] = marker;
                }
            } else if (vehicleMarkers[unit]) {
                map.removeLayer(vehicleMarkers[unit]);
                delete vehicleMarkers[unit];
            }
        }
    }
    for (const inc of incs) {
        const loc = inc.location || {};
        if (inc.active && loc.lat && loc.lon) {
            if (incidentMarkers[inc.id]) {
                incidentMarkers[inc.id].setLatLng([loc.lat, loc.lon]);
            } else {
                incidentMarkers[inc.id] = L.marker([loc.lat, loc.lon], {icon: incidentIcon})
                    .addTo(map)
                    .bindPopup(`${inc.keyword} - ${loc.name}`);
            }
        } else if (incidentMarkers[inc.id]) {
            map.removeLayer(incidentMarkers[inc.id]);
            delete incidentMarkers[inc.id];
        }
    }
    fitMapToAll();
    } catch (err) {
        console.error('Aktualisierung fehlgeschlagen', err);
        setConnectionStatus(false);
    } finally {
        refreshing = false;
        if (refreshQueued) {
            refreshQueued = false;
            refresh();
        }
    }
}
const connectionStatusEl = document.createElement('div');
connectionStatusEl.id = 'connection-status';
connectionStatusEl.className = 'badge bg-danger position-fixed top-0 end-0 m-3 fs-6';
connectionStatusEl.textContent = 'Getrennt';
connectionStatusEl.style.zIndex = '2000';
document.body.appendChild(connectionStatusEl);

function setConnectionStatus(connected) {
    if (connected) {
        connectionStatusEl.classList.remove('bg-danger');
        connectionStatusEl.classList.add('bg-success');
        connectionStatusEl.textContent = 'Verbunden';
    } else {
        connectionStatusEl.classList.remove('bg-success');
        connectionStatusEl.classList.add('bg-danger');
        connectionStatusEl.textContent = 'Verbindung getrennt';
    }
}

let eventSource = null;
let reconnectTimer = null;

function scheduleReconnect() {
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectEventStream();
    }, 5000);
}

function connectEventStream() {
    if (eventSource) {
        eventSource.close();
    }
    eventSource = new EventSource('/events');
    eventSource.onopen = () => {
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onmessage = () => {
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onerror = () => {
        setConnectionStatus(false);
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        scheduleReconnect();
    };
}

window.addEventListener('beforeunload', () => {
    if (eventSource) {
        eventSource.close();
    }
});

setConnectionStatus(false);
connectEventStream();
refresh();
setInterval(() => {
    refresh();
}, 30000);
</script>
{% endblock %}
