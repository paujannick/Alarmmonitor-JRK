{% extends 'base.html' %}
{% block head_extra %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html, body { overflow: hidden; }
</style>
{% endblock %}
{% block container_class %}container-fluid p-0 vh-100 d-flex flex-column{% endblock %}
{% block content %}
<div class="flex-grow-0 px-3">
<h1 class="mb-2">Alarmmonitor</h1>
<div id="datetime" class="text-end text-secondary mb-2"></div>
<button id="fullscreen" class="btn btn-secondary mb-2">Vollbild</button>
<div id="latest-incident" class="alert alert-danger display-4" style="display:none;"></div>
<button id="enable-audio" class="btn btn-secondary mb-2">Ton aktivieren</button>
</div>
<div class="row flex-grow-1 g-0">
  <div class="col-md-6 h-100">
    <div id="map" class="h-100"></div>
  </div>
  <div class="col-md-6 d-flex flex-column h-100">
    <div id="vehicle-table-container" class="flex-grow-1 overflow-hidden">
      <table class="table table-dark table-striped" id="vehicle-table">
        <thead>
          <tr>
            <th>Fahrzeug / Funkrufname</th>
            <th>Icon</th>
            <th>Status</th>
            <th>Hinweis</th>
            <th>Ort</th>
            <th>Farbe</th>
          </tr>
        </thead>
        <tbody>
        {% for name, info in vehicles.items() %}
          <tr data-unit="{{ name }}" class="status-{{ info.status }}">
            <td class="unit-cell"><strong>{{ info.name }}</strong><br><small>{{ info.callsign }}</small></td>
            <td class="icon-cell">{% if info.icon %}<img src="{{ url_for('static', filename=info.icon) }}" height="24">{% endif %}</td>
            <td class="status-text">{{ info.status }} - {{ status_text[info.status] }}</td>
            <td class="note">{{ info.note }}</td>
            <td class="location">{{ info.location }}</td>
            <td class="status-color-cell"><span class="status-color"></span></td>
          </tr>
        {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>
<audio id="alarm" preload="auto">
  <source src="{{ url_for('static', filename='gong.mp3') }}" type="audio/mpeg">
  <source src="{{ url_for('static', filename='gong.wav') }}" type="audio/wav">
</audio>
{% endblock %}
{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const vehicleData = {{ vehicles|tojson }};
const statusText = {{ status_text|tojson }};
const lastAlarmIds = {};
let lastAlarmUnit = null;
const vehicleIcons = {};
for (const [unit, info] of Object.entries(vehicleData)) {
    const initId = info.alarm_time || info.incident_id;
    lastAlarmIds[unit] = initId ? `${unit}:${initId}` : null;
    if (info.icon) {
        vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
    }
}
const alarmSound = document.getElementById('alarm');
const latestDiv = document.getElementById('latest-incident');
const enableBtn = document.getElementById('enable-audio');
const fullscreenBtn = document.getElementById('fullscreen');
const datetimeEl = document.getElementById('datetime');
let audioUnlocked = false;
const ttsEl = new Audio();
let lastAlarmId = null;
const alarmQueue = [];
let alarmProcessing = false;
let refreshing = false;
let refreshQueued = false;
const map = L.map('map').setView([50.517, 8.816], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '© OpenStreetMap'}).addTo(map);
const vehicleMarkers = {};
const incidentMarkers = {};
const iconBase = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/';

function scaleMonitor() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const cw = document.body.scrollWidth;
    const ch = document.body.scrollHeight;
    const scale = Math.min(w / cw, h / ch);
    document.body.style.transformOrigin = '0 0';
    document.body.style.transform = `scale(${scale})`;
    document.body.style.width = `${100 / scale}%`;
    document.body.style.height = `${100 / scale}%`;
    map.invalidateSize();
}
window.addEventListener('resize', scaleMonitor);
document.addEventListener('DOMContentLoaded', scaleMonitor);
function computeAlarmId(unit, info) {
    const uniqueId = info.alarm_time || info.incident_id || Date.now();
    return `${unit}:${uniqueId}`;
}
function unlockAudio() {
    alarmSound.play().then(() => {
        alarmSound.pause();
        alarmSound.currentTime = 0;
        audioUnlocked = true;
        enableBtn.style.display = 'none';
    }).catch(() => {
        audioUnlocked = false;
        enableBtn.style.display = '';
    });
}
enableBtn.addEventListener('click', unlockAudio, {once: true});
document.addEventListener('touchstart', unlockAudio, {once: true});
document.addEventListener('click', unlockAudio, {once: true});
function fitMapToAll() {
    const markers = [
        ...Object.values(vehicleMarkers),
        ...Object.values(incidentMarkers)
    ].filter(m => m);
    if (Object.keys(incidentMarkers).length === 0) {
        map.setView([50.517, 8.816], 13);
    } else if (markers.length) {
        const group = new L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.05));
    }
}
const icons = {
  RTW: new L.Icon({iconUrl: iconBase + 'marker-icon-red.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  KTW: new L.Icon({iconUrl: iconBase + 'marker-icon-blue.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
  default: new L.Icon({iconUrl: iconBase + 'marker-icon-grey.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]}),
};
const incidentIcon = new L.Icon({iconUrl: iconBase + 'marker-icon-green.png', shadowUrl: iconBase + 'marker-shadow.png', iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34], shadowSize:[41,41]});
function getIcon(unit) {
  if (vehicleIcons[unit]) return vehicleIcons[unit];
  if (unit.startsWith('RTW')) return icons.RTW;
  if (unit.startsWith('KTW')) return icons.KTW;
  return icons.default;
}
fullscreenBtn.addEventListener('click', () => {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  }
});
if (document.documentElement.requestFullscreen) {
  document.documentElement.requestFullscreen().catch(() => {});
}
document.addEventListener('fullscreenchange', () => {
  const nav = document.querySelector('nav');
  if (document.fullscreenElement) {
    if (nav) nav.style.display = 'none';
    fullscreenBtn.style.display = 'none';
  } else {
    if (nav) nav.style.display = '';
    fullscreenBtn.style.display = '';
  }
});

function updateDateTime() {
  const now = new Date();
  datetimeEl.textContent = now.toLocaleString('de-DE');
}
setInterval(updateDateTime, 1000);
updateDateTime();
function speak(text) {
    const t = (text || '').trim();
    if (!t) return Promise.resolve();
      if ('speechSynthesis' in window) {
          return new Promise(resolve => {
              const utterance = new SpeechSynthesisUtterance(t);
              utterance.lang = 'de-DE';
              utterance.onend = resolve;
              utterance.onerror = resolve;
              window.speechSynthesis.speak(utterance);
          });
      }
    if (!audioUnlocked) {
        enableBtn.style.display = '';
        return Promise.resolve();
    }
    return new Promise(resolve => {
        const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=de&q=${encodeURIComponent(t)}`;
        ttsEl.src = url;
        ttsEl.onended = resolve;
        ttsEl.play().catch(() => resolve());
    });
}

function triggerAlarm(unit, info, alarmId) {
    alarmId = alarmId || computeAlarmId(unit, info);
    if (alarmId === lastAlarmId) return;
    lastAlarmId = alarmId;
    lastAlarmUnit = unit;
    const displayCallsign = info.callsign || unit;
    const speechCallsign = info.tts || displayCallsign;
    const parts = [`Alarm für ${speechCallsign}`];
    if (info.note) parts.push(info.note);
    if (info.location) parts.push(info.location);
    const speechText = parts.join('. ');
    const displayText = `${info.note || ''} ${info.location || ''}`.trim();
    alarmQueue.push({alarmId, displayCallsign, speechText, displayText});
    if (!alarmProcessing) {
        alarmProcessing = true;
        if (audioUnlocked) {
            alarmSound.currentTime = 0;
            alarmSound.play().then(() => {
                alarmSound.onended = () => {
                    alarmSound.onended = null;
                    processAlarmQueue();
                };
            }).catch(() => {
                processAlarmQueue();
            });
        } else {
            enableBtn.style.display = '';
            processAlarmQueue();
        }
    }
    if (info.lat && info.lon) {
        if (vehicleMarkers[unit]) {
            vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
            vehicleMarkers[unit].setIcon(getIcon(unit));
        } else {
            vehicleMarkers[unit] = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map).bindPopup(displayCallsign);
        }
    }
    fitMapToAll();
}

function processAlarmQueue() {
    const item = alarmQueue.shift();
    if (!item) {
        alarmProcessing = false;
        lastAlarmId = null;
        return;
    }
    latestDiv.innerHTML = `<strong>${item.displayCallsign}</strong> ${item.displayText}`;
    latestDiv.style.display = 'block';
    speak(item.speechText).then(() => processAlarmQueue());
}

async function refresh() {
    if (refreshing) {
        refreshQueued = true;
        return;
    }
    refreshing = true;
    try {
        const [statusRes, incidentsRes] = await Promise.all([
            fetch('/api/status', {cache: 'no-store'}),
            fetch('/api/incidents', {cache: 'no-store'})
        ]);
        if (!statusRes.ok || !incidentsRes.ok) {
            throw new Error('Netzwerkfehler');
        }
        const data = await statusRes.json();
        const incs = await incidentsRes.json();
        setConnectionStatus(true);
        for (const [unit, info] of Object.entries(data)) {
        vehicleData[unit] = info;
        const row = document.querySelector(`tr[data-unit="${unit}"]`);
        if (row) {
            row.className = `status-${info.status}`;
            row.querySelector('.status-text').textContent = `${info.status} - ${statusText[info.status]}`;
            row.querySelector('.note').textContent = info.note;
            row.querySelector('.location').textContent = info.location;
            row.querySelector('.unit-cell').innerHTML = `<strong>${info.name}</strong><br><small>${info.callsign}</small>`;
            const iconCell = row.querySelector('.icon-cell');
            if (info.icon) {
                iconCell.innerHTML = `<img src="/static/${info.icon}" height="24">`;
                vehicleIcons[unit] = L.icon({iconUrl:`/static/${info.icon}`, iconSize:[32,32], iconAnchor:[16,16]});
            } else {
                iconCell.innerHTML = '';
                delete vehicleIcons[unit];
            }
            const hasAlertInfo = info.note || info.location;
            const alarmId = (info.alarm_time || info.incident_id) ? computeAlarmId(unit, info) : null;
            if (alarmId && alarmId !== lastAlarmIds[unit]) {
                triggerAlarm(unit, info, alarmId);
            }
            if (lastAlarmUnit === unit && !hasAlertInfo) {
                latestDiv.style.display = 'none';
                lastAlarmUnit = null;
                lastAlarmId = null;
            }
            lastAlarmIds[unit] = alarmId;
            if (info.lat && info.lon) {
                if (vehicleMarkers[unit]) {
                    vehicleMarkers[unit].setLatLng([info.lat, info.lon]);
                    vehicleMarkers[unit].setIcon(getIcon(unit));
                } else {
                    vehicleMarkers[unit] = L.marker([info.lat, info.lon], {icon: getIcon(unit)}).addTo(map).bindPopup(info.callsign || unit);
                }
            } else if (vehicleMarkers[unit]) {
                map.removeLayer(vehicleMarkers[unit]);
                delete vehicleMarkers[unit];
            }
        }
    }
    for (const inc of incs) {
        const loc = inc.location || {};
        if (inc.active && loc.lat && loc.lon) {
            if (incidentMarkers[inc.id]) {
                incidentMarkers[inc.id].setLatLng([loc.lat, loc.lon]);
            } else {
                incidentMarkers[inc.id] = L.marker([loc.lat, loc.lon], {icon: incidentIcon})
                    .addTo(map)
                    .bindPopup(`${inc.keyword} - ${loc.name}`);
            }
        } else if (incidentMarkers[inc.id]) {
            map.removeLayer(incidentMarkers[inc.id]);
            delete incidentMarkers[inc.id];
        }
    }
    fitMapToAll();
    } catch (err) {
        console.error('Aktualisierung fehlgeschlagen', err);
        setConnectionStatus(false);
    } finally {
        refreshing = false;
        if (refreshQueued) {
            refreshQueued = false;
            refresh();
        }
    }
}
const connectionStatusEl = document.createElement('div');
connectionStatusEl.id = 'connection-status';
connectionStatusEl.className = 'badge bg-danger position-fixed top-0 end-0 m-3 fs-6';
connectionStatusEl.textContent = 'Getrennt';
connectionStatusEl.style.zIndex = '2000';
document.body.appendChild(connectionStatusEl);

function setConnectionStatus(connected) {
    if (connected) {
        connectionStatusEl.classList.remove('bg-danger');
        connectionStatusEl.classList.add('bg-success');
        connectionStatusEl.textContent = 'Verbunden';
    } else {
        connectionStatusEl.classList.remove('bg-success');
        connectionStatusEl.classList.add('bg-danger');
        connectionStatusEl.textContent = 'Verbindung getrennt';
    }
}

let eventSource = null;
let reconnectTimer = null;

function scheduleReconnect() {
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectEventStream();
    }, 5000);
}

function connectEventStream() {
    if (eventSource) {
        eventSource.close();
    }
    eventSource = new EventSource('/events');
    eventSource.onopen = () => {
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onmessage = () => {
        setConnectionStatus(true);
        refresh();
    };
    eventSource.onerror = () => {
        setConnectionStatus(false);
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        scheduleReconnect();
    };
}

window.addEventListener('beforeunload', () => {
    if (eventSource) {
        eventSource.close();
    }
});

setConnectionStatus(false);
connectEventStream();
refresh();
setInterval(() => {
    refresh();
}, 30000);
</script>
{% endblock %}
